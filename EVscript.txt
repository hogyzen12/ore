(() => {
    // ---------- Config ----------
    const ORE_TOKEN_ADDRESS = 'oreoU2P8bN6jkk3jbaiVxYnG1dCXcYxwhwyK9jSybcp';
    const REF_MULT = 0.9;
    const ADMIN_FEE = 0.01;
    const PROTOCOL_CUT = 0.10;
    const P_WIN = 1 / 25;
    const HIT_PROB = 1 / 625;
    const UPDATE_MS = 1000;
    const RESET_DELAY_MS = 5000;
    const PRICE_UPDATE_MS = 15_000; // Update prices every 15 seconds// Dynamic prices (will be updated from API)
let PRICE_ORE_USD = 110; // Fallback value
let PRICE_SOL_USD = 200; // Fallback value
let priceOreSol = PRICE_ORE_USD / PRICE_SOL_USD;

const ADMIN_COST_FACTOR = ADMIN_FEE / (1 - ADMIN_FEE);
const C = 24 + (ADMIN_COST_FACTOR) / P_WIN;

// Track round state
let lastRoundNumber = null;
let roundResetTime = null;
let isInCooldown = false;
let lastHighlightedEV = null;

// ---------- Price Fetching ----------
async function updatePrices() {
  try {
    // Fetch ORE token data
    const oreResponse = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${ORE_TOKEN_ADDRESS}`);
    const oreData = await oreResponse.json();
    
    if (oreData && oreData.pairs && oreData.pairs.length > 0) {
      // Find the most liquid pair (highest volume or liquidity)
      const bestPair = oreData.pairs.reduce((best, pair) => {
        const volume = parseFloat(pair.volume?.h24 || 0);
        const bestVolume = parseFloat(best.volume?.h24 || 0);
        return volume > bestVolume ? pair : best;
      });
      
      const orePrice = parseFloat(bestPair.priceUsd);
      if (orePrice && orePrice > 0) {
        PRICE_ORE_USD = orePrice;
        console.log(` ORE price updated: $${PRICE_ORE_USD.toFixed(2)}`);
      }
    }
    
    // Fetch SOL price (using wrapped SOL address)
    const solAddress = 'So11111111111111111111111111111111111111112';
    const solResponse = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${solAddress}`);
    const solData = await solResponse.json();
    
    if (solData && solData.pairs && solData.pairs.length > 0) {
      const bestPair = solData.pairs.reduce((best, pair) => {
        const volume = parseFloat(pair.volume?.h24 || 0);
        const bestVolume = parseFloat(best.volume?.h24 || 0);
        return volume > bestVolume ? pair : best;
      });
      
      const solPrice = parseFloat(bestPair.priceUsd);
      if (solPrice && solPrice > 0) {
        PRICE_SOL_USD = solPrice;
        console.log(` SOL price updated: $${PRICE_SOL_USD.toFixed(2)}`);
      }
    }
    
    // Update derived price
    priceOreSol = PRICE_ORE_USD / PRICE_SOL_USD;
    console.log(` ORE/SOL ratio: ${priceOreSol.toFixed(6)}`);
    
  } catch (error) {
    if (error.status === 429) {
      console.warn(' Rate limited, backing off...');
      const newInterval = Math.min(PRICE_UPDATE_MS * 2, 60000);
      clearInterval(window.__orePriceInterval);
      window.__orePriceInterval = setInterval(updatePrices, newInterval);
    }
    console.error(' Error fetching prices from DexScreener:', error);
    console.log(' Using last known prices: ORE=$' + PRICE_ORE_USD.toFixed(2) + ', SOL=$' + PRICE_SOL_USD.toFixed(2));
  }
}

// ---------- Helpers ----------
function selectGridButtons() {
  const grids = Array.from(document.querySelectorAll('div.grid.grid-cols-5'));
  for (const g of grids) {
    const btns = g.querySelectorAll(':scope > button');
    if (btns.length === 25) return Array.from(btns);
  }
  return [];
}

function parseRoundNumber() {
  const buttons = Array.from(document.querySelectorAll('button'));
  for (const btn of buttons) {
    const text = btn.textContent || '';
    const match = text.match(/Round\s*#([\d,]+)/i);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''), 10);
    }
  }
  return null;
}

function parseBlockNumber(btn) {
  const text = btn.textContent || '';
  const match = text.match(/#(\d+)/);
  return match ? parseInt(match[1]) : null;
}

function parseBlockSOL(btn) {
  const spans = Array.from(btn.querySelectorAll('span'));
  for (let i = spans.length - 1; i >= 0; i--) {
    const raw = (spans[i].textContent || '').trim().replace(/,/g, '');
    if (/^\d+(\.\d+)?$/.test(raw) && raw.includes('.')) {
      const v = parseFloat(raw);
      if (!isNaN(v)) return v;
    }
  }
  const text = (btn.textContent || '').replace(/\s+/g, ' ').trim().replace(/,/g, '');
  const matches = text.match(/\d+\.\d+/g);
  if (matches && matches.length) {
    const v = parseFloat(matches[matches.length - 1]);
    if (!isNaN(v)) return v;
  }
  return 0;
}

function parseMotherlodeORE() {
  const buttons = Array.from(document.querySelectorAll('button'));
  const mBtn = buttons.find(b => ((b.textContent || '').toLowerCase().includes('motherlode')));
  if (!mBtn) return null;

  const txt = (mBtn.textContent || '').replace(/,/g, '');
  const dec = txt.match(/\d+\.\d+/);
  if (dec) return parseFloat(dec[0]);

  const parts = Array.from(txt.matchAll(/(\d+\.\d+)|(\.\d+)|(\d+)/g)).map(m => m[0]);
  for (let i = 0; i < parts.length; i++) {
    if (/^\d+$/.test(parts[i]) && i + 1 < parts.length && /^\.\d+$/.test(parts[i + 1])) {
      return parseFloat(parts[i] + parts[i + 1]);
    }
  }
  for (const p of parts) {
    if (/^\d+$/.test(p)) return parseFloat(p);
  }
  return null;
}

function formatSol(x) {
  const abs = Math.abs(x);
  const sign = x >= 0 ? '+' : '-';
  
  if (abs === 0) return '+0.0000';
  
  // For very small values, use subscript notation
  if (abs < 0.01) {
    const str = abs.toFixed(10);
    const afterDecimal = str.split('.')[1];
    let leadingZeros = 0;
    for (let i = 0; i < afterDecimal.length; i++) {
      if (afterDecimal[i] === '0') {
        leadingZeros++;
      } else {
        break;
      }
    }
    
    if (leadingZeros >= 2) {
      const significantPart = afterDecimal.substring(leadingZeros);
      const truncated = significantPart.substring(0, 4);
      
      const subscripts = ['₀', '₁', '₂', '₃', '₄', '₅', '₆', '₇', '₈', '₉'];
      const subscriptNum = leadingZeros.toString().split('').map(d => subscripts[parseInt(d)]).join('');
      
      return `${sign}0.0${subscriptNum}${truncated}`;
    }
  }
  
  // For normal values, use standard decimal notation
  if (abs < 0.1) {
    return sign + abs.toFixed(5);
  } else if (abs < 1) {
    return sign + abs.toFixed(4);
  } else {
    return sign + abs.toFixed(3);
  }
}

function clearOldHighlights() {
  document.querySelectorAll('.ore-ev-overlay').forEach(el => {
    if (el.parentNode) el.parentNode.removeChild(el);
  });

  const allButtons = selectGridButtons();
  allButtons.forEach(btn => {
    btn.classList.remove('ore-ev-highlighted');
    btn.style.position = '';
    btn.style.boxShadow = '';
    btn.style.borderColor = '';
    btn.style.border = '';
    btn.style.outline = '';
  });

  document.querySelectorAll('.ore-ev-highlighted').forEach(el => {
    el.classList.remove('ore-ev-highlighted');
    el.style.position = '';
    el.style.boxShadow = '';
    el.style.borderColor = '';
    el.style.border = '';
    el.style.outline = '';
  });

  lastHighlightedEV = null;
}

function showEV(btn, evValue, isHighest) {
  if (getComputedStyle(btn).position === 'static') {
    btn.style.position = 'relative';
  }

  if (isHighest) {
    btn.classList.add('ore-ev-highlighted');
    btn.style.boxShadow = '0 0 0 3px rgba(0,255,0,0.95) inset, 0 0 10px rgba(0,255,0,0.5)';
    btn.style.borderColor = 'rgba(0,255,0,0.95)';
  }

  let overlay = document.createElement('div');
  overlay.className = 'ore-ev-overlay';
  
  let textColor, fontWeight;
  if (isHighest && evValue > 0) {
    textColor = '#2dff2d';
    fontWeight = '700';
  } else if (evValue < 0) {
    textColor = '#ff6b6b';
    fontWeight = '600';
  } else if (evValue < 0.0001) {
    textColor = '#888888';
    fontWeight = '500';
  } else {
    textColor = '#cccccc';
    fontWeight = '600';
  }
  
  const bgOpacity = isHighest ? '0.90' : '0.80';
  
  overlay.style.cssText = `
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    padding: 2px 5px;
    background: rgba(0,0,0,${bgOpacity});
    color: ${textColor};
    font-weight: ${fontWeight};
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    border-radius: 3px;
    font-size: 0.75em;
    white-space: nowrap;
    z-index: 1000;
    line-height: 1.2;
  `;
  overlay.textContent = `${formatSol(evValue)}`;
  btn.appendChild(overlay);
}

function computeEVStarForBlock(O, T, oreValueInSOL) {
  if (!isFinite(O) || O <= 0) return { y: 0, EV: -Infinity };
  if (!isFinite(T) || T <= 0) return { y: 0, EV: -Infinity };

  const V_initial = (1 - PROTOCOL_CUT) * (T - O) + oreValueInSOL;
  if (V_initial <= 0) return { y: 0, EV: -Infinity };

  let yStar = Math.sqrt((oreValueInSOL * O) / C); // Initial guess
  let V = V_initial;
  
  // Iterate to account for your own contribution reducing the pool
  for (let i = 0; i < 3; i++) {
    V = (1 - PROTOCOL_CUT) * (T - O - yStar) + oreValueInSOL;
    if (V <= 0) break;
    yStar = Math.max(0, Math.sqrt((V * O) / C) - O);
  }
  
  if (yStar <= 0) return { y: 0, EV: 0 };

  const f = yStar / (O + yStar);
  const adminCost = ADMIN_COST_FACTOR * yStar;
  const EV = P_WIN * (-24 * yStar + V * f) - adminCost;
  return { y: yStar, EV };
}

function tick() {
  try {
    const btns = selectGridButtons();
    if (btns.length !== 25) {
      clearOldHighlights();
      return;
    }

    const currentRoundNumber = parseRoundNumber();

    if (lastRoundNumber !== null && currentRoundNumber !== null) {
      if (currentRoundNumber !== lastRoundNumber) {
        console.log(` Round reset detected! Round #${lastRoundNumber} → #${currentRoundNumber}`);
        clearOldHighlights();
        roundResetTime = Date.now();
        isInCooldown = true;
        lastRoundNumber = currentRoundNumber;
        return;
      }
    }

    if (currentRoundNumber !== null) {
      lastRoundNumber = currentRoundNumber;
    }

    if (isInCooldown) {
      const elapsed = Date.now() - roundResetTime;
      if (elapsed < RESET_DELAY_MS) {
        clearOldHighlights();
        return;
      } else {
        isInCooldown = false;
        console.log(` Cooldown complete for Round #${currentRoundNumber}. EV calculations resumed.`);
      }
    }

    const blocks = btns.map(btn => ({
      btn,
      blockNum: parseBlockNumber(btn),
      O: parseBlockSOL(btn)
    }));

    const T = blocks.reduce((acc, b) => acc + (isFinite(b.O) && b.O > 0 ? b.O : 0), 0);

    if (T < 0.1) {
      clearOldHighlights();
      return;
    }

    const M = parseMotherlodeORE();
    const expectedMotherlodeOREThisRound = (M != null && isFinite(M)) ? (M * HIT_PROB) : (0.2 * HIT_PROB);
    const oreValueInSOL = priceOreSol * REF_MULT * (1 + expectedMotherlodeOREThisRound);

    clearOldHighlights();

    let best = null;
    const validBlocks = [];
    
    for (const b of blocks) {
      if (!isFinite(b.O) || b.O <= 0) continue;

      const { y, EV } = computeEVStarForBlock(b.O, T, oreValueInSOL);
      b.y = y;
      b.EV = EV;
      
      if (isFinite(EV)) {
        validBlocks.push(b);
        if (!best || EV > best.EV) {
          best = b;
        }
      }
    }

    for (const b of validBlocks) {
      const isHighest = (best && b === best && b.EV > 0);
      showEV(b.btn, b.EV, isHighest);
    }

  } catch (e) {
    console.error('EV highlighter error:', e);
  }
}

// Start price updates immediately and then every 5 seconds
updatePrices();
if (window.__orePriceInterval) clearInterval(window.__orePriceInterval);
window.__orePriceInterval = setInterval(updatePrices, PRICE_UPDATE_MS);

// Start EV calculations
if (window.__oreEvInterval) clearInterval(window.__oreEvInterval);
window.__oreEvInterval = setInterval(tick, UPDATE_MS);

clearOldHighlights();
tick();

// Expose stop function
window.oreEvStop = () => {
  clearInterval(window.__oreEvInterval);
  clearInterval(window.__orePriceInterval);
  window.__oreEvInterval = null;
  window.__orePriceInterval = null;
  clearOldHighlights();
  console.log('ORE EV highlighter stopped.');
};

console.log(' ORE EV highlighter running with live prices from DexScreener!');
console.log(' Prices update every 5 seconds. Call oreEvStop() to stop.');  })();Can you analyse this code pls - i want to focus in on the +EV part off it as this is key in my opinion

Thought for 9s

Overview of the ScriptThis JavaScript code appears to be a userscript or bookmarklet designed to run on a specific website (likely a crypto mining or betting game interface involving ORE tokens on Solana). It overlays real-time Expected Value (EV) calculations on a 5x5 grid of buttons, each representing a "block" with a SOL value. The script:Fetches live prices for ORE and SOL from DexScreener API every 15 seconds (with fallbacks and rate-limit handling).
Parses the UI to extract round numbers, block SOL values, and "Motherlode" ORE rewards.
Computes EV for each block, highlighting the one with the highest positive EV (+EV) in green.
Runs continuously every 1 second, with a 5-second cooldown after round resets to avoid stale data.

The core focus is on identifying +EV opportunities—situations where the expected return from "betting" (or mining) on a block exceeds the cost, making it statistically profitable over many rounds. This is visualized with overlays showing EV in SOL (e.g., "+0.1234" or very small values in subscript notation). Negative or zero EV blocks get dimmer overlays, and only the top +EV block (if any) gets a bright green highlight.The script assumes a game mechanic where:You "bet" SOL on one of 25 blocks.
There's a 1/25 chance (P_WIN) of winning the block's prize pool.
Prizes include ORE tokens (valued in SOL), with a small chance (HIT_PROB = 1/625) of hitting a "Motherlode" bonus.
Fees: 1% admin fee, 10% protocol cut.
Referral multiplier (0.9x) adjusts ORE value.

Now, let's dive deep into the +EV logic, as requested.Key Constants and Assumptions Influencing EVThese are hardcoded and drive the math:P_WIN = 1/25 (0.04): Probability of winning a block. Implies a fair-game baseline, but fees and pool dynamics make it -EV by default.
HIT_PROB = 1/625 (0.0016): Chance of a Motherlode hit, adding extra ORE value.
REF_MULT = 0.9: Referral discount multiplier on ORE rewards.
ADMIN_FEE = 0.01 (1%): Fee on your bet.
PROTOCOL_CUT = 0.10 (10%): Cut from the prize pool.
C = 24 + (ADMIN_COST_FACTOR) / P_WIN: Derived constant (~24 + 25/0.99 ≈ 49.25). The "24" might represent a fixed cost or baseline (possibly in ORE units?).
oreValueInSOL: Dynamic ORE value in SOL, fetched from API. Includes expected Motherlode: priceOreSol * REF_MULT * (1 + expectedMotherlodeOREThisRound).expectedMotherlodeOREThisRound = Motherlode ORE * HIT_PROB (parsed from UI, fallback 0.2 * HIT_PROB ≈ 0.00032 ORE).

Prices start with fallbacks (ORE $110, SOL $200) but update live.

EV is only computed if total SOL across blocks (T) > 0.1 and individual block SOL (O) > 0. Invalid blocks get -Infinity EV and are skipped.Breakdown of the EV CalculationThe heart of +EV is in computeEVStarForBlock(O, T, oreValueInSOL), which finds the optimal bet amount (yStar) and its EV for a single block.Step 1: Initial Prize Pool Value (V_initial)

V_initial = (1 - PROTOCOL_CUT) * (T - O) + oreValueInSOL

T: Total SOL bet across all 25 blocks (sum of O values).
O: SOL already bet on this specific block.
This calculates the net prize pool for this block:Exclude this block's O (since you're competing against it).
Subtract 10% protocol cut.
Add the block's ORE reward value in SOL (dynamic, ~0.9 * priceOreSol + tiny Motherlode expectation).

If V_initial <= 0, EV = -Infinity (no value in betting).

Step 2: Optimal Bet Amount (yStar)This uses an iterative approximation to find yStar, the SOL amount you should bet to maximize EV. It's based on a square-root formula, suggesting a Kelly-like criterion for proportional betting in a pool.

yStar = Math.sqrt((oreValueInSOL * O) / C); // Initial guess

Then iterate 3 times to adjust for your bet diluting the pool:

V = (1 - PROTOCOL_CUT) * (T - O - yStar) + oreValueInSOL
yStar = Math.max(0, Math.sqrt((V * O) / C) - O)

Why sqrt? This derives from optimizing EV in a multiplicative pool (f = yStar / (O + yStar), see below). It's like betting proportional to sqrt(value * existing bets) minus fees.
If yStar <= 0 after iteration, EV = 0 (not worth betting).

Step 3: Compute EV for yStar

f = yStar / (O + yStar)  // Your fractional ownership of the block after betting
adminCost = ADMIN_COST_FACTOR * yStar  // ~1.01% of yStar (ADMIN_FEE / (1 - ADMIN_FEE) ≈ 0.0101)
EV = P_WIN * (-24 * yStar + V * f) - adminCost

Breakdown of the EV Formula:P_WIN * V * f: Expected winnings from the prize pool (V), scaled by your ownership fraction (f).
P_WIN * (-24 * yStar): Fixed loss term. This subtracts 24 * yStar with probability P_WIN—possibly a game-specific penalty (e.g., 24 ORE cost on win?). Multiplied by P_WIN, it's like an expected fixed cost of ~0.96 SOL per bet (24 * yStar / 25), but scaled to yStar.
-adminCost: Always pay ~1% on your bet yStar.

Net EV: Expected profit in SOL. Positive if winnings outweigh costs/fees.
The "-24 * yStar" is a key drag—without it, EV would be higher. This might model a mining difficulty or reward burn.

What Makes EV Positive (+EV)?EV > 0 when:High V relative to costs: V must be large enough to cover the -24*yStar term and fees. V grows with T (total bets) but shrinks if O is high (more competition on this block).
Low O relative to T: Best opportunities are under-bet blocks (low O) in high-total rounds (high T). Your yStar "fills the gap" to claim a big f.
High oreValueInSOL: Driven by ORE price spikes or high Motherlode. If ORE/SOL ratio > fallback 0.55 (110/200), EV improves.
Optimal yStar > 0: If sqrt((V*O)/C) > O, you bet; else, skip.
Threshold: Roughly, EV > 0 requires V * f > (24 * yStar + adminCost / P_WIN) ≈ 24yStar + 0.25yStar (since P_WIN=1/25).Simplifying: Need V > ~24 * (O + yStar) (ignoring fees). High T and oreValue help here.

In practice: The script scans all 25 blocks, computes EV, and highlights the max if >0. If all EV <=0, no highlight—implying -EV round overall.

Example (hypothetical, based on formula):Assume T=10 SOL, O=0.1 SOL (under-bet block), oreValueInSOL=0.5.
V_initial ≈ 0.9 * (10 - 0.1) + 0.5 ≈ 9.41
yStar ≈ sqrt((0.5*0.1)/49.25) - 0.1 ≈ 0.03 (after iteration).
f ≈ 0.03 / 0.13 ≈ 0.23
EV ≈ (1/25) * (-240.03 + 9.410.23) - 0.0101*0.03 ≈ 0.04 * ( -0.72 + 2.16) - 0.0003 ≈ 0.0576 - 0.0003 = +0.0573 SOL
If O=1 (more competition), yStar shrinks, EV might flip negative.

Visualization and +EV HighlightingIn showEV(): +EV gets bright text (#2dff2d if highest). The top +EV block gets a green glow/box-shadow.
Small +EV (<0.01) uses subscript for tiny values (e.g., +0.0₂3456 for 0.00023456).
Clears old highlights on round reset or errors.
Only shows if EV is finite and block is valid.

Potential Caveats and Why +EV Matters+EV as Key Insight: You're right—this is the script's value prop. In gambling/mining games, +EV means long-term profit (e.g., bet yStar on highlighted block repeatedly). -EV rounds are skips. The math optimizes for edge over house (fees/protocol).
Risks: Assumes perfect execution (no slippage, instant bets).
Ignores variance: Even +EV can lose short-term (1/25 win rate).
API reliance: DexScreener outages use fallbacks, potentially skewing EV.
Game changes: If P_WIN, fees, or "24" constant shift, EV miscalculates.
Iteration limit (3 loops): Good approximation but not exact for huge T.

Improvements: Could add risk-adjustment (e.g., half-Kelly for variance), simulate multiple bets, or alert on +EV > threshold.
Ethical Note: This seems for a Solana-based game (ORE token). Ensure it's not violating ToS; +EV edges can attract bots, leading to bans.

If you share more context (e.g., the website or test values for O/T), I can simulate specific EV calcs using code execution.

